"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamsSiteProxy = void 0;
const core_1 = require("@amazon-connect/core");
const site_1 = require("@amazon-connect/site");
class StreamsSiteProxy extends site_1.SiteProxy {
    constructor(provider) {
        super(provider);
        this.ccpIFrame = null;
        this.unexpectedIframeWarningCount = 0;
    }
    get proxyType() {
        return "streams-site";
    }
    setCCPIframe(iframe) {
        const isCcpIFrameSet = Boolean(this.ccpIFrame);
        this.ccpIFrame = iframe;
        this.unexpectedIframeWarningCount = 0;
        if (isCcpIFrameSet)
            this.resetConnection("CCP IFrame Updated");
    }
    getUpstreamMessageOrigin() {
        return Object.assign({ _type: "streams-site", providerId: this.provider.id }, (0, core_1.getOriginAndPath)());
    }
    verifyEventSource(evt) {
        const ccpIFrame = this.ccpIFrame;
        if (!ccpIFrame) {
            this.proxyLogger.error("CCP Iframe not provided to proxy. Unable to verify event to Connect to CCP.", {
                origin: evt.origin,
            });
            return false;
        }
        const valid = evt.source === ccpIFrame.contentWindow;
        if (!valid) {
            this.unexpectedIframeWarningCount++;
            if (this.unexpectedIframeWarningCount < 5) {
                this.proxyLogger.warn("Message came from unexpected iframe. Not a valid CCP. Will not connect", {
                    origin: evt.origin,
                    unexpectedIframeWarningCount: this.unexpectedIframeWarningCount,
                });
            }
        }
        return valid;
    }
    invalidInitMessageHandler() {
        // CCP sends messages via Streams
        // Take no action here
    }
}
exports.StreamsSiteProxy = StreamsSiteProxy;
//# sourceMappingURL=streams-site-proxy.js.map