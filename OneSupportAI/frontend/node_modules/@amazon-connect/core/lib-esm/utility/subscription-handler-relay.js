var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ConnectLogger } from "../logging";
import { createModuleProxy } from "../proxy";
export class SubscriptionHandlerRelay {
    constructor(provider) {
        this.handlersMap = new Map();
        this.provider = provider;
        this.logger = new ConnectLogger({
            source: "subscription-handler-relay",
            provider,
            mixin: () => ({
                namespace: this.namespace,
                topicKey: this.topicKey,
            }),
        });
    }
    get supportsParameter() {
        return true;
    }
    on(handler, parameter) {
        if (parameter && !this.supportsParameter) {
            throw new Error("on provided unsupported parameter");
        }
        const parameterHandlerMap = this.getParameterInternalHandlerMap(handler);
        // Do not add when handler / parameter pair already exists
        if (parameterHandlerMap.has(parameter))
            return;
        const internalHandler = ((evt) => __awaiter(this, void 0, void 0, function* () {
            if (this.skipRelay(evt))
                return;
            let externalEvent;
            try {
                externalEvent = yield this.translate(evt);
            }
            catch (error) {
                this.logger.error("An error occurred when translating event", {
                    error,
                    parameter,
                });
                // Stop execution. Rethrowing would produce a duplicate error message.
                return;
            }
            try {
                yield handler(externalEvent);
            }
            catch (error) {
                this.logger.error("Error in event handler", {
                    error,
                    parameter,
                });
            }
        }));
        parameterHandlerMap.set(parameter, internalHandler);
        this.getProxy().subscribe({ key: this.topicKey, parameter }, internalHandler);
    }
    off(handler, parameter) {
        var _a;
        if (parameter && !this.supportsParameter) {
            throw new Error("off provided unsupported parameter");
        }
        const internalHandler = (_a = this.handlersMap.get(handler)) === null || _a === void 0 ? void 0 : _a.get(parameter);
        if (!internalHandler)
            return;
        const parameterMap = this.handlersMap.get(handler);
        if ((parameterMap === null || parameterMap === void 0 ? void 0 : parameterMap.delete(parameter)) && parameterMap.size < 1)
            this.handlersMap.delete(handler);
        this.getProxy().unsubscribe({ key: this.topicKey, parameter }, internalHandler);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    skipRelay(event) {
        return false;
    }
    destroy() {
        const proxy = this.getProxy();
        for (const [externalHandler, parameterMapping] of this.handlersMap) {
            for (const [parameter, internalHandler] of parameterMapping) {
                proxy.unsubscribe({ key: this.topicKey, parameter }, internalHandler);
                parameterMapping.delete(parameter);
            }
            this.handlersMap.delete(externalHandler);
        }
    }
    getParameterInternalHandlerMap(externalHandler) {
        if (!this.handlersMap.has(externalHandler)) {
            this.handlersMap.set(externalHandler, new Map());
        }
        return this.handlersMap.get(externalHandler);
    }
    getProxy() {
        if (!this.proxy) {
            const proxy = this.provider.getProxy();
            this.proxy = createModuleProxy(proxy, this.namespace);
        }
        return this.proxy;
    }
}
//# sourceMappingURL=subscription-handler-relay.js.map