import { AmazonConnectConfig } from "../amazon-connect-config";
import { AmazonConnectError, AmazonConnectErrorHandler } from "../amazon-connect-error";
import { AmazonConnectNamespace } from "../amazon-connect-namespace";
import { ConnectLogger, LogProxy, ProxyLogData } from "../logging";
import { AcknowledgeMessage, ChildConnectionEnabledDownstreamMessage, ChildConnectionEnabledUpstreamMessage, LogMessage, MetricMessage, UpstreamMessageOrigin } from "../messaging";
import { SubscriptionHandler, SubscriptionHandlerData, SubscriptionTopic } from "../messaging/subscription";
import { MetricProxy, ProxyMetricData } from "../metric";
import { AmazonConnectProvider } from "../provider";
import { ConnectRequestData, ConnectResponseData } from "../request";
import { UpdateChannelPortParams } from "./channel-manager";
import { HealthCheckStatusChangedHandler } from "./health-check";
import { ProxyConnectionChangedHandler, ProxyConnectionStatus, ProxyConnectionStatusManager } from "./proxy-connection";
import type { AddChildChannelDirectParams, AddChildChannelPortParams } from "./proxy-types";
export declare abstract class Proxy<TConfig extends AmazonConnectConfig = AmazonConnectConfig, TUpstreamMessage extends {
    type: string;
} | ChildConnectionEnabledUpstreamMessage = ChildConnectionEnabledUpstreamMessage, TDownstreamMessage extends {
    type: string;
} | ChildConnectionEnabledDownstreamMessage = ChildConnectionEnabledDownstreamMessage> implements LogProxy, MetricProxy {
    protected readonly provider: AmazonConnectProvider<TConfig>;
    protected readonly status: ProxyConnectionStatusManager;
    private readonly subscriptions;
    private readonly errorService;
    protected readonly logger: ConnectLogger;
    private readonly channelManager;
    private readonly healthCheck;
    private requestManager;
    private upstreamMessageQueue;
    private connectionEstablished;
    private isInitialized;
    private connectionId;
    constructor(provider: AmazonConnectProvider<TConfig>);
    init(): void;
    protected abstract initProxy(): void;
    request<TResponse extends ConnectResponseData>(namespace: AmazonConnectNamespace, command: string, data?: ConnectRequestData, origin?: UpstreamMessageOrigin): Promise<TResponse>;
    subscribe<THandlerData extends SubscriptionHandlerData>(topic: SubscriptionTopic, handler: SubscriptionHandler<THandlerData>, origin?: UpstreamMessageOrigin): void;
    unsubscribe<THandlerData extends SubscriptionHandlerData>(topic: SubscriptionTopic, handler: SubscriptionHandler<THandlerData>, origin?: UpstreamMessageOrigin): void;
    log(logData: ProxyLogData): void;
    sendLogMessage(message: LogMessage): void;
    sendMetric({ metricData, time, namespace }: ProxyMetricData): void;
    sendMetricMessage(metricMessage: MetricMessage): void;
    protected sendOrQueueMessageToSubject(message: TUpstreamMessage): void;
    protected abstract sendMessageToSubject(message: TUpstreamMessage): void;
    protected abstract addContextToLogger(): Record<string, unknown>;
    protected abstract getUpstreamMessageOrigin(): UpstreamMessageOrigin;
    protected consumerMessageHandler(evt: {
        data: any;
    }): void;
    protected handleMessageFromSubject(msg: TDownstreamMessage): void;
    private handleDefaultMessageFromSubject;
    protected handleConnectionAcknowledge(msg: AcknowledgeMessage): void;
    private handleResponse;
    private handlePublish;
    private handleError;
    protected publishError(error: Omit<AmazonConnectError, "connectionStatus">): void;
    private handleAsyncSubscriptionHandlerInvoke;
    abstract get proxyType(): string;
    get connectionStatus(): ProxyConnectionStatus;
    onError(handler: AmazonConnectErrorHandler): void;
    offError(handler: AmazonConnectErrorHandler): void;
    onConnectionStatusChange(handler: ProxyConnectionChangedHandler): void;
    offConnectionStatusChange(handler: ProxyConnectionChangedHandler): void;
    onHealthCheckStatusChanged(handler: HealthCheckStatusChangedHandler): void;
    offHealthCheckStatusChanged(handler: HealthCheckStatusChangedHandler): void;
    /**
     * @deprecated Use addChildIframeChannel instead. This method will be removed in a future version.
     */
    addChildChannel(params: AddChildChannelPortParams): void;
    /**
     * Adds a component-based child channel to the proxy.
     *
     * This method establishes a communication channel using component function calls instead
     * of MessagePorts. This is useful when both the proxy and child entity exist in the same
     * execution context, such as within the same browser window or iframe.
     *
     * Component channels provide better performance than iframe channels since they avoid
     * the overhead of serialization and can support synchronous communication patterns.
     *
     * @param params - Component channel configuration
     * @param params.connectionId - UUID identifier for this channel connection
     * @param params.providerId - UUID of the provider that owns this channel
     * @param params.sendDownstreamMessage - Function to send messages to the child entity
     * @param params.setUpstreamMessageHandler - Function to register upstream message handler
     *
     * @example
     * ```typescript
     * proxy.addChildComponentChannel({
     *   connectionId: "child-uuid",
     *   providerId: "provider-uuid",
     *   sendDownstreamMessage: (message) => childComponent.receive(message),
     *   setUpstreamMessageHandler: (handler) => childComponent.onUpstream = handler
     * });
     * ```
     */
    addChildIframeChannel(params: AddChildChannelPortParams): void;
    /**
     * Adds a component-based child channel for communication with child entities.
     *
     * This method establishes a communication channel using direct function calls instead
     * of MessagePorts. This is useful when both the proxy and child entity exist in the same
     * execution context and can directly reference each other's functions.
     *
     * @param params - Configuration parameters for the component function channel
     * @param params.connectionId - Unique UUID identifier for this channel connection
     * @param params.providerId - UUID of the provider that owns this channel connection
     * @param params.sendDownstreamMessage - Function to send messages from proxy to child entity
     * @param params.setUpstreamMessageHandler - Function to register handler for messages from child entity
     *
     * @example
     * ```typescript
     * // Child entity exposes these functions
     * const childAPI = {
     *   receive: (message) => { },
     *   onUpstream: null as ((message) => void) | null
     * };
     *
     * proxy.addChildComponentChannel({
     *   connectionId: "550e8400-e29b-41d4-a716-446655440001", // UUID
     *   providerId: "6ba7b810-9dad-11d1-80b4-00c04fd430c8", // UUID
     *   sendDownstreamMessage: (message) => {
     *     childAPI.receive(message);
     *   },
     *   setUpstreamMessageHandler: (handler) => {
     *     childAPI.onUpstream = handler;
     *   }
     * });
     * ```
     */
    addChildComponentChannel(params: AddChildChannelDirectParams): void;
    /**
     * Updates an existing iframe channel with a new MessagePort.
     *
     * This method is only applicable to iframe channels. Component channels cannot
     * be updated and will result in an error. The old MessagePort is properly cleaned up
     * (event listeners removed, port closed) before the new port is configured.
     *
     * @param params - Update parameters
     * @param params.connectionId - UUID identifier for the channel to update
     * @param params.port - New MessagePort instance to replace the existing one
     * @param params.providerId - UUID of the provider that owns this channel
     *
     * @example
     * ```typescript
     * const { port1, port2 } = new MessageChannel();
     * proxy.updateChildIframeChannelPort({
     *   connectionId: "550e8400-e29b-41d4-a716-446655440000",
     *   port: port1,
     *   providerId: "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
     * });
     * ```
     */
    updateChildIframeChannelPort(params: UpdateChannelPortParams): void;
    /**
     * @deprecated Use updateChildIframeChannelPort instead. This method will be removed in a future version.
     */
    updateChildChannelPort(params: UpdateChannelPortParams): void;
    getConnectionId(): Promise<string>;
    protected resetConnection(reason: string): void;
    protected restoreAllHandler(): {
        subscriptionHandlerCount: number;
    };
    protected unsubscribeAllHandlers(): void;
}
//# sourceMappingURL=proxy.d.ts.map