var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { ConnectLogger, createLogMessage, } from "../logging";
import { SubscriptionManager, } from "../messaging/subscription";
import { createMetricMessage } from "../metric";
import { createRequestMessage, RequestManager, } from "../request";
import { ChannelManager } from "./channel-manager";
import { ErrorService } from "./error";
import { HealthCheckManager, } from "./health-check";
import { ProxyConnectionStatusManager, } from "./proxy-connection";
export class Proxy {
    constructor(provider) {
        this.provider = provider;
        this.logger = new ConnectLogger({
            source: "core.proxy",
            provider,
            mixin: () => ({
                proxyType: this.proxyType,
                connectionId: this.connectionId,
            }),
        });
        this.requestManager = new RequestManager(provider);
        this.status = new ProxyConnectionStatusManager(provider);
        this.errorService = new ErrorService(provider);
        this.upstreamMessageQueue = [];
        this.connectionEstablished = false;
        this.isInitialized = false;
        this.subscriptions = new SubscriptionManager();
        this.connectionId = null;
        this.channelManager = new ChannelManager(provider, this.sendOrQueueMessageToSubject.bind(this));
        this.healthCheck = new HealthCheckManager({
            provider,
            sendHealthCheck: this.sendOrQueueMessageToSubject.bind(this),
            getUpstreamMessageOrigin: this.getUpstreamMessageOrigin.bind(this),
        });
    }
    init() {
        if (this.isInitialized)
            throw new Error("Proxy already initialized");
        this.isInitialized = true;
        this.initProxy();
    }
    request(namespace, command, data, origin) {
        const msg = createRequestMessage(namespace, command, data, origin !== null && origin !== void 0 ? origin : this.getUpstreamMessageOrigin());
        const resp = this.requestManager.processRequest(msg);
        this.sendOrQueueMessageToSubject(msg);
        return resp;
    }
    subscribe(topic, handler, origin) {
        const { handlerId } = this.subscriptions.add(topic, handler);
        const msg = {
            type: "subscribe",
            topic,
            messageOrigin: origin !== null && origin !== void 0 ? origin : this.getUpstreamMessageOrigin(),
            handlerId,
        };
        this.sendOrQueueMessageToSubject(msg);
    }
    unsubscribe(topic, handler, origin) {
        this.subscriptions.delete(topic, handler);
        if (this.subscriptions.isEmpty(topic)) {
            const msg = {
                type: "unsubscribe",
                topic,
                messageOrigin: origin !== null && origin !== void 0 ? origin : this.getUpstreamMessageOrigin(),
            };
            this.sendOrQueueMessageToSubject(msg);
        }
    }
    log(logData) {
        const logMsg = createLogMessage(logData, this.addContextToLogger(), this.getUpstreamMessageOrigin());
        this.sendOrQueueMessageToSubject(logMsg);
    }
    sendLogMessage(message) {
        if (message.type !== "log") {
            this.logger.error("Attempted to send invalid log message", {
                message,
            });
            return;
        }
        message.context = Object.assign(Object.assign({}, message.context), this.addContextToLogger());
        this.sendOrQueueMessageToSubject(message);
    }
    sendMetric({ metricData, time, namespace }) {
        const metricMessage = createMetricMessage({
            metricData,
            time,
            namespace,
        }, this.getUpstreamMessageOrigin());
        this.sendOrQueueMessageToSubject(metricMessage);
    }
    sendMetricMessage(metricMessage) {
        if (metricMessage.type !== "metric") {
            this.logger.error("Attempted to send invalid metric message", {
                metricMessage,
            });
            return;
        }
        this.sendOrQueueMessageToSubject(metricMessage);
    }
    sendOrQueueMessageToSubject(message) {
        if (this.connectionEstablished) {
            this.sendMessageToSubject(message);
        }
        else {
            this.upstreamMessageQueue.push(message);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    consumerMessageHandler(evt) {
        if (!this.isInitialized) {
            this.logger.error("Attempted to process message from subject prior to proxy being initializing. Message not processed", { originalMessageEventData: evt.data });
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const { data } = evt;
        if (!("type" in data)) {
            // TODO Clean this up... probably safe to ignore without logging
            this.logger.warn("Unknown inbound message", {
                originalMessageEventData: data,
            });
            return;
        }
        // Naming of type confusing because outbound to worker is inbound to client
        const msg = data;
        this.handleMessageFromSubject(msg);
    }
    handleMessageFromSubject(msg) {
        this.handleDefaultMessageFromSubject(msg);
    }
    handleDefaultMessageFromSubject(msg) {
        switch (msg.type) {
            case "acknowledge":
                this.handleConnectionAcknowledge(msg);
                break;
            case "response":
                this.handleResponse(msg);
                break;
            case "publish":
                this.handlePublish(msg);
                break;
            case "error":
                this.handleError(msg);
                break;
            case "childDownstreamMessage":
                this.channelManager.handleDownstreamMessage(msg);
                break;
            case "childConnectionClose":
                this.channelManager.handleCloseMessage(msg);
                break;
            case "healthCheckResponse":
                this.healthCheck.handleResponse(msg);
                break;
            default:
                this.logger.error("Unknown inbound message", {
                    originalMessageEventData: msg,
                });
                return;
        }
    }
    handleConnectionAcknowledge(msg) {
        this.connectionId = msg.connectionId;
        this.status.update({
            status: "ready",
            connectionId: msg.connectionId,
        });
        this.connectionEstablished = true;
        // Sends any messages in queue
        while (this.upstreamMessageQueue.length) {
            const msg = this.upstreamMessageQueue.shift();
            this.sendMessageToSubject(msg);
        }
        this.healthCheck.start(msg);
    }
    handleResponse(msg) {
        this.requestManager.processResponse(msg);
    }
    handlePublish(msg) {
        const { handlerId, topic } = msg;
        if (handlerId) {
            const handler = this.subscriptions.getById(topic, handlerId);
            if (handler) {
                void this.handleAsyncSubscriptionHandlerInvoke({ handler, handlerId }, msg);
            }
        }
        else {
            this.subscriptions
                .get(topic)
                .map((handlerIdMapping) => void this.handleAsyncSubscriptionHandlerInvoke(handlerIdMapping, msg));
        }
    }
    handleError(msg) {
        if (msg.isFatal) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { message: reason, type: _ } = msg, details = __rest(msg, ["message", "type"]);
            this.status.update({ status: "error", reason: reason, details });
        }
        this.publishError({
            message: msg.message,
            key: msg.key,
            details: msg.details,
            isFatal: msg.isFatal,
            proxyStatus: msg.status,
        });
    }
    publishError(error) {
        const fullError = Object.assign(Object.assign({}, error), { connectionStatus: this.connectionStatus });
        this.errorService.invoke(fullError);
    }
    handleAsyncSubscriptionHandlerInvoke(_a, _b) {
        return __awaiter(this, arguments, void 0, function* ({ handler, handlerId }, { topic, data }) {
            try {
                yield handler(data);
            }
            catch (error) {
                this.logger.error("An error occurred when handling subscription", {
                    topic,
                    error,
                    handlerId,
                });
            }
        });
    }
    get connectionStatus() {
        return this.status.getStatus();
    }
    onError(handler) {
        this.errorService.onError(handler);
    }
    offError(handler) {
        this.errorService.offError(handler);
    }
    onConnectionStatusChange(handler) {
        this.status.onChange(handler);
    }
    offConnectionStatusChange(handler) {
        this.status.offChange(handler);
    }
    onHealthCheckStatusChanged(handler) {
        this.healthCheck.onStatusChanged(handler);
    }
    offHealthCheckStatusChanged(handler) {
        this.healthCheck.offStatusChanged(handler);
    }
    /**
     * @deprecated Use addChildIframeChannel instead. This method will be removed in a future version.
     */
    addChildChannel(params) {
        // Legacy method that only supports MessagePort channels
        this.addChildIframeChannel(params);
    }
    /**
     * Adds a component-based child channel to the proxy.
     *
     * This method establishes a communication channel using component function calls instead
     * of MessagePorts. This is useful when both the proxy and child entity exist in the same
     * execution context, such as within the same browser window or iframe.
     *
     * Component channels provide better performance than iframe channels since they avoid
     * the overhead of serialization and can support synchronous communication patterns.
     *
     * @param params - Component channel configuration
     * @param params.connectionId - UUID identifier for this channel connection
     * @param params.providerId - UUID of the provider that owns this channel
     * @param params.sendDownstreamMessage - Function to send messages to the child entity
     * @param params.setUpstreamMessageHandler - Function to register upstream message handler
     *
     * @example
     * ```typescript
     * proxy.addChildComponentChannel({
     *   connectionId: "child-uuid",
     *   providerId: "provider-uuid",
     *   sendDownstreamMessage: (message) => childComponent.receive(message),
     *   setUpstreamMessageHandler: (handler) => childComponent.onUpstream = handler
     * });
     * ```
     */
    addChildIframeChannel(params) {
        this.channelManager.addChannel(Object.assign(Object.assign({}, params), { type: "iframe" }));
    }
    /**
     * Adds a component-based child channel for communication with child entities.
     *
     * This method establishes a communication channel using direct function calls instead
     * of MessagePorts. This is useful when both the proxy and child entity exist in the same
     * execution context and can directly reference each other's functions.
     *
     * @param params - Configuration parameters for the component function channel
     * @param params.connectionId - Unique UUID identifier for this channel connection
     * @param params.providerId - UUID of the provider that owns this channel connection
     * @param params.sendDownstreamMessage - Function to send messages from proxy to child entity
     * @param params.setUpstreamMessageHandler - Function to register handler for messages from child entity
     *
     * @example
     * ```typescript
     * // Child entity exposes these functions
     * const childAPI = {
     *   receive: (message) => { },
     *   onUpstream: null as ((message) => void) | null
     * };
     *
     * proxy.addChildComponentChannel({
     *   connectionId: "550e8400-e29b-41d4-a716-446655440001", // UUID
     *   providerId: "6ba7b810-9dad-11d1-80b4-00c04fd430c8", // UUID
     *   sendDownstreamMessage: (message) => {
     *     childAPI.receive(message);
     *   },
     *   setUpstreamMessageHandler: (handler) => {
     *     childAPI.onUpstream = handler;
     *   }
     * });
     * ```
     */
    addChildComponentChannel(params) {
        this.channelManager.addChannel(Object.assign(Object.assign({}, params), { type: "component" }));
    }
    /**
     * Updates an existing iframe channel with a new MessagePort.
     *
     * This method is only applicable to iframe channels. Component channels cannot
     * be updated and will result in an error. The old MessagePort is properly cleaned up
     * (event listeners removed, port closed) before the new port is configured.
     *
     * @param params - Update parameters
     * @param params.connectionId - UUID identifier for the channel to update
     * @param params.port - New MessagePort instance to replace the existing one
     * @param params.providerId - UUID of the provider that owns this channel
     *
     * @example
     * ```typescript
     * const { port1, port2 } = new MessageChannel();
     * proxy.updateChildIframeChannelPort({
     *   connectionId: "550e8400-e29b-41d4-a716-446655440000",
     *   port: port1,
     *   providerId: "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
     * });
     * ```
     */
    updateChildIframeChannelPort(params) {
        this.channelManager.updateChannelPort(params);
    }
    /**
     * @deprecated Use updateChildIframeChannelPort instead. This method will be removed in a future version.
     */
    updateChildChannelPort(params) {
        this.updateChildIframeChannelPort(params);
    }
    getConnectionId() {
        if (this.connectionId)
            return Promise.resolve(this.connectionId);
        return new Promise((resolve, reject) => {
            let timeout = undefined;
            const handler = (evt) => {
                if (evt.status === "ready") {
                    this.offConnectionStatusChange(handler);
                    clearInterval(timeout);
                    resolve(evt.connectionId);
                }
            };
            timeout = setTimeout(() => {
                this.logger.error("Timeout getting connection id");
                this.offConnectionStatusChange(handler);
                reject(new Error("Timeout getting connectionId"));
            }, 10 * 1000);
            this.onConnectionStatusChange(handler);
        });
    }
    resetConnection(reason) {
        this.connectionEstablished = false;
        this.status.update({
            status: "reset",
            reason,
        });
        const { subscriptionHandlerCount } = this.restoreAllHandler();
        this.logger.info("Resetting proxy", {
            reason,
            subscriptionHandlerCount,
        });
    }
    restoreAllHandler() {
        var _a;
        const subscriptionHandlerIds = this.subscriptions.getAllSubscriptionHandlerIds();
        // Restore all subscriptions
        subscriptionHandlerIds === null || subscriptionHandlerIds === void 0 ? void 0 : subscriptionHandlerIds.map(({ topic, handlerId }) => ({
            type: "subscribe",
            topic,
            messageOrigin: this.getUpstreamMessageOrigin(),
            handlerId,
        })).forEach((msg) => this.sendOrQueueMessageToSubject(msg));
        return { subscriptionHandlerCount: (_a = subscriptionHandlerIds === null || subscriptionHandlerIds === void 0 ? void 0 : subscriptionHandlerIds.length) !== null && _a !== void 0 ? _a : -1 };
    }
    unsubscribeAllHandlers() {
        var _a;
        const subscriptionHandlerIds = this.subscriptions.getAllSubscriptionHandlerIds();
        this.logger.info("Unsubscribing all handlers from proxy", {
            subscriptionHandlerCount: (_a = subscriptionHandlerIds === null || subscriptionHandlerIds === void 0 ? void 0 : subscriptionHandlerIds.length) !== null && _a !== void 0 ? _a : -1,
        });
        subscriptionHandlerIds === null || subscriptionHandlerIds === void 0 ? void 0 : subscriptionHandlerIds.map(({ topic }) => ({
            type: "unsubscribe",
            topic,
            messageOrigin: this.getUpstreamMessageOrigin(),
        })).forEach((msg) => this.sendOrQueueMessageToSubject(msg));
    }
}
//# sourceMappingURL=proxy.js.map