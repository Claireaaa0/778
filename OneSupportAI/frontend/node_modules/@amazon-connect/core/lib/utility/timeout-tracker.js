"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeoutTracker = void 0;
const logging_1 = require("../logging");
class TimeoutTracker {
    constructor(onCancelled, timeoutMs) {
        this.timeoutMs = timeoutMs;
        this.onCancelled = onCancelled;
        this.timeout = setTimeout(() => this.handleCancel(), this.timeoutMs);
        this.status = "running";
        this.logger = new logging_1.ConnectLogger({
            source: "core.utility.timeout-tracker",
            mixin: () => ({
                timeoutMs: this.timeoutMs,
                timeoutTrackerStatus: this.status,
            }),
        });
    }
    static start(onCancelled, ms) {
        return new TimeoutTracker(onCancelled, ms);
    }
    complete() {
        switch (this.status) {
            case "running":
                return this.handleComplete();
            case "completed":
                this.logger.debug("TimeoutTracker already marked complete. No action.");
                return true;
            case "cancelled":
                this.logger.info("Attempted to complete a TimeoutTracker that has already been cancelled");
                return false;
        }
    }
    isCancelled() {
        return this.status === "cancelled";
    }
    getStatus() {
        return this.status;
    }
    handleCancel() {
        switch (this.status) {
            case "running":
                this.status = "cancelled";
                this.logger.info("TimeoutTracker has timed out. Invoking onCancelled Handler");
                this.invokeOnCancelled();
                break;
            case "completed":
                this.logger.debug("Cancel operation for TimerTracker invoked after already completed. No action.");
                break;
            default:
                throw new Error("Cancel operation in TimerTracker called during an unexpected time.");
        }
    }
    handleComplete() {
        this.status = "completed";
        clearTimeout(this.timeout);
        return true;
    }
    invokeOnCancelled() {
        try {
            this.onCancelled({ timeoutMs: this.timeoutMs });
        }
        catch (error) {
            this.logger.error("Error when attempting to invoke TimeoutTrackerCancelledHandler", { error });
        }
    }
}
exports.TimeoutTracker = TimeoutTracker;
//# sourceMappingURL=timeout-tracker.js.map