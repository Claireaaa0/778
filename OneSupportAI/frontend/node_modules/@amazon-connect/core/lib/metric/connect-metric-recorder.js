"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectMetricRecorder = void 0;
const provider_1 = require("../provider");
const duration_metric_recorder_1 = require("./duration-metric-recorder");
const metric_helpers_1 = require("./metric-helpers");
/**
 * @classdesc ConnectMetricRecorder class provides APIs to emit metrics based on users' need
 */
class ConnectMetricRecorder {
    /**
     * Constructor for ConnectMetricRecorder
     * @param {ConnectRecorderMetricParams} params - The namespace and provider(optional)
     */
    constructor(params) {
        this._proxy = null;
        this.namespace = params.namespace;
        if (params.provider && typeof params.provider === "function")
            this.providerFactory = params.provider;
        else
            this.provider = params.provider;
    }
    /**
     * Emit a metric that counts success
     * @param {string} metricName - The name of the metric
     * @param {Record<string, string>} dimensions - The dimensions of a metric with keys and values (optional)
     * @param {Record<string, string>} optionalDimensions - The optional dimensions of a metric with keys and values (optional)
     */
    recordSuccess(metricName, metricOptions) {
        var _a;
        const processedDimensions = Object.assign({}, ((_a = metricOptions === null || metricOptions === void 0 ? void 0 : metricOptions.dimensions) !== null && _a !== void 0 ? _a : {}));
        const processedMetricOptions = Object.assign(Object.assign({}, metricOptions), { dimensions: processedDimensions });
        this.recordCount(metricName, 0, processedMetricOptions);
    }
    /**
     * Emit a metric that counts error. Add default dimension { name: "Metric", value: "Error" } to the metric if not added
     * @param {string} metricName - The name of the metric
     * @param {Record<string, string>} dimensions - The dimensions of a metric with keys and values (optional)
     * @param {Record<string, string>} optionalDimensions - The optional dimensions of a metric with keys and values (optional)
     */
    recordError(metricName, metricOptions) {
        var _a;
        const processedDimensions = Object.assign({}, ((_a = metricOptions === null || metricOptions === void 0 ? void 0 : metricOptions.dimensions) !== null && _a !== void 0 ? _a : {}));
        const processedMetricOptions = Object.assign(Object.assign({}, metricOptions), { dimensions: processedDimensions });
        this.recordCount(metricName, 1, processedMetricOptions);
    }
    /**
     * Emit a counting metric
     * @param {string} metricName - The name of the metric
     * @param {number} count - The count of the metric
     * @param {Record<string, string>} dimensions - The dimensions of a metric with keys and values (optional)
     * @param {Record<string, string>} optionalDimensions - The optional dimensions of a metric with keys and values (optional)
     */
    recordCount(metricName, count, metricOptions) {
        this.sendMetric({
            metricName,
            unit: "Count",
            value: count,
            dimensions: metricOptions === null || metricOptions === void 0 ? void 0 : metricOptions.dimensions,
            optionalDimensions: metricOptions === null || metricOptions === void 0 ? void 0 : metricOptions.optionalDimensions,
        });
    }
    /**
     * Start a duration metric
     * @param {string} metricName - The name of the metric
     * @param {Record<string, string>} dimensions - The dimensions of a metric with keys and values (optional)
     * @param {Record<string, string>} optionalDimensions - The optional dimensions of a metric with keys and values (optional)
     * @returns {DurationMetricRecorder} - The DurationMetricRecorder object being created
     */
    startDurationCounter(metricName, metricOptions) {
        return new duration_metric_recorder_1.DurationMetricRecorder({
            sendMetric: this.sendMetric.bind(this),
            metricName,
            metricOptions,
        });
    }
    /**
     * Emit metric
     * @param {string} metricName - The name of the metric
     * @param {unit} unit - The unit of the metric
     * @param {number} value - The value of the metric
     * @param {Record<string, string>} dimensions - The dimensions of a metric with keys and values (optional)
     * @param {Record<string, string>} optionalDimensions - The optional dimensions of a metric with keys and values (optional)
     */
    sendMetric({ metricName, unit, value, dimensions, optionalDimensions, }) {
        if (dimensions) {
            (0, metric_helpers_1.checkDimensionLength)(dimensions, optionalDimensions);
        }
        const metricData = {
            metricName,
            unit,
            value,
            dimensions,
            optionalDimensions,
        };
        const time = new Date();
        this.getProxy().sendMetric({
            metricData,
            time,
            namespace: this.namespace,
        });
    }
    /**
     * Get the provider of the ConnectMetricRecorder instance
     */
    getProvider() {
        if (!this.provider) {
            this.provider = this.providerFactory
                ? this.providerFactory()
                : (0, provider_1.getGlobalProvider)();
        }
        return this.provider;
    }
    /**
     * Get the proxy of the ConnectMetricRecorder instance
     */
    getProxy() {
        if (!this._proxy) {
            this._proxy = this.getProvider().getProxy();
        }
        return this._proxy;
    }
}
exports.ConnectMetricRecorder = ConnectMetricRecorder;
//# sourceMappingURL=connect-metric-recorder.js.map