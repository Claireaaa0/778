"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_METRIC_DIMENSIONS = void 0;
exports.checkDimensionLength = checkDimensionLength;
exports.createMetricMessage = createMetricMessage;
exports.MAX_METRIC_DIMENSIONS = 30;
/**
 * Check if the the sum of the length of dimensions and optional dimentions is exceeding maximum dimension length acceptable by back-end
 * @param {Record<string, string>} dimensions - The dimensions of the duration metric with keys and values
 * @param {Record<string, string>} optionalDimensions -The optional dimensions of the duration metric with keys and values
 */
function checkDimensionLength(dimensions, optionalDimensions) {
    if (Object.keys(dimensions).length +
        Object.keys(optionalDimensions !== null && optionalDimensions !== void 0 ? optionalDimensions : {}).length >
        exports.MAX_METRIC_DIMENSIONS) {
        throw new Error("Cannot add more than 30 dimensions to a metric");
    }
}
/**
 * Transform the metric message into the format acceptable by back-end
 * @param {MetricData} metricData - The metric data
 * @param {string} timestamp - The timestamp of the metric
 * @param {string} namespace - The namespace of the metric
 * @param {UpstreamMessageOrigin} messageOrigin - The origin of the metric message
 * @return {MetricMessage} - Return a MetricMessage object
 */
function createMetricMessage({ metricData, time, namespace }, messageOrigin) {
    var _a, _b;
    return {
        type: "metric",
        namespace: namespace,
        metricName: metricData.metricName,
        unit: metricData.unit,
        value: metricData.value,
        time: time,
        dimensions: (_a = metricData.dimensions) !== null && _a !== void 0 ? _a : {},
        optionalDimensions: (_b = metricData.optionalDimensions) !== null && _b !== void 0 ? _b : {},
        messageOrigin,
    };
}
//# sourceMappingURL=metric-helpers.js.map