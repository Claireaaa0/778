"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SiteProxy = void 0;
const core_1 = require("@amazon-connect/core");
class SiteProxy extends core_1.Proxy {
    constructor(provider, instanceUrl) {
        super(provider);
        if (instanceUrl !== undefined) {
            // Two-parameter constructor: use the explicit instanceUrl parameter
            this.instanceUrl = instanceUrl;
        }
        else {
            // Single-parameter constructor: get instanceUrl from config
            this.instanceUrl = provider.config.instanceUrl;
        }
        this.postMessageHandler = this.listenForInitialMessage.bind(this);
        this.proxyLogger = new core_1.ConnectLogger({
            source: "siteProxy",
            provider,
        });
    }
    initProxy() {
        this.status.update({ status: "connecting" });
        window.addEventListener("message", this.postMessageHandler);
    }
    resetConnection(reason) {
        super.resetConnection(reason);
        this.messagePort = undefined;
        this.status.update({ status: "connecting" });
    }
    sendMessageToSubject(message) {
        if (this.messagePort) {
            this.messagePort.postMessage(message);
        }
        else {
            // This could ever be reached if the setup did not occur and the
            // acknowledge process was initiated by non supported means.
            this.proxyLogger.error("Failed to send UpstreamMessage. MessagePort not set", {
                messageType: message.type,
            });
        }
    }
    addContextToLogger() {
        return {};
    }
    listenForInitialMessage(evt) {
        // Verify origin
        if (!this.verifyOrigin(evt)) {
            // Log message is handled in the function with the actual reason for failure
            return;
        }
        if (this.verifyEventSource(evt)) {
            // Verify message
            if (evt.data.type !== "cross-domain-adapter-init") {
                this.invalidInitMessageHandler(evt.data);
                return;
            }
            // When a message port already exists
            if (this.messagePort) {
                this.resetConnection("Subsequent Message Port Detected");
                this.proxyLogger.info("Subsequent message port received. Resetting connection");
            }
            this.messagePort = evt.ports[0];
            if (!this.messagePort) {
                throw new Error("message port not provided by iframe");
            }
            this.messagePort.onmessage = this.consumerMessageHandler.bind(this);
            this.status.update({ status: "initializing" });
            this.messagePort.postMessage({
                type: "cross-domain-site-ready",
                providerId: this.provider.id,
            });
            this.proxyLogger.debug("CDA Post message handler removed");
        }
    }
    verifyOrigin(evt) {
        const eventOrigin = evt.origin;
        if (!eventOrigin) {
            this.proxyLogger.warn("No origin provided in event. Ignoring event.");
            return false;
        }
        let expectedOrigin;
        try {
            expectedOrigin = new URL(this.instanceUrl).origin;
        }
        catch (error) {
            this.proxyLogger.error("Unable to parse expected origin from instanceUrl. Cannot match", {
                error,
                eventOrigin,
                instanceUrl: this.instanceUrl,
            }, { duplicateMessageToConsole: true });
            return false;
        }
        if (eventOrigin !== expectedOrigin) {
            if (evt.data.type === "cross-domain-adapter-init") {
                // Only logging for the specific handshake message. Otherwise just ignore
                this.proxyLogger.warn("Origin of message with type 'cross-domain-adapter-init' did not expected instance value. Ignoring", {
                    expectedOrigin,
                    eventOrigin,
                }, { duplicateMessageToConsole: true });
            }
            return false;
        }
        return true;
    }
}
exports.SiteProxy = SiteProxy;
//# sourceMappingURL=site-proxy.js.map